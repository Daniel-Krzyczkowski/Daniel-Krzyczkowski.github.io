---
title: "IoT with Azure Serverless and UWP"
excerpt: "In this article would like to present how to connect Azure Serverless services together with IoT device to display real time data in the UWP application."
---

<p align="center">
<img src="/images/devisland/article21/assets/ServerlessIoT1.png?raw=true" alt="IoT with Azure Serverless and UWP"/>
</p>

Recently I had a case where SignalR service was used toghether with ASP .NET Core Web API. I thought that it would be nice to check how SignalR service works with Azure Functions and UWP applications. This is why I created sample scenario where real time IoT data is displayed in the UWP application.


## Solution architecture

Here is the solution architecture. IoT device with sensors sends data to the Azure IoT Hub. Then Function app is triggered each time new data is sent to the IoT hub.
Once data is received, Function app connected with SignalR service is triggered. At the end UWP application can display real time data generated by the IoT device's sensors.

<p align="center">
<img src="/images/devisland/article21/assets/ServerlessIoT2.png?raw=true" alt="Image not found"/>
</p>

<p align="center">
<img src="/images/devisland/article21/assets/ServerlessIoT7.gif?raw=true" alt="Image not found"/>
</p>


## IoT Hub config

Let's start from the Azure IoT Hub configuration. New IoT Hub instance has to be created - free plan is totally fine. Once IoT Hub is created, new device should be registered:

<p align="center">
<img src="/images/devisland/article21/assets/ServerlessIoT5.PNG?raw=true" alt="Image not found"/>
</p>

Copy connection string because we will use it in the next section to connect IoT device:

<p align="center">
<img src="/images/devisland/article21/assets/ServerlessIoT6.PNG?raw=true" alt="Image not found"/>
</p>


## IoT device config

For this project I used Azure IoT DevKit board (MxChip). It has many sensors including temperature and humidity. You can find [instructions](https://microsoft.github.io/azure-iot-developer-kit/docs/get-started/) how to setup your machine to develop for MxChip and create sample project I used in this article.
Device will send humidity and temperature data to the Azure IoT Hub.


## SignalR service config

Azure SignalR service enables sending real time messages. You can read more about it in the [official documentation](https://docs.microsoft.com/en-us/azure/azure-signalr/signalr-overview). When creating Azure SignalR service remember to set "ServiceMode" to "Serverless". I encourage you to read more about serice modes [here](https://github.com/Azure/azure-signalr/blob/dev/docs/faq.md#what-is-the-meaning-of-service-mode-defaultserverlessclassic-how-can-i-choose).

Once service is created copy "Primary connection string" from the "Keys" tab. We will use it later in the article.


## Device-data-trigger function config

Once data is received in the IoT Hub, "Device-data-trigger" function is triggered. In the source code of this function we can access device telemetry data (temperature or humidity):

```csharp
    public static class DeviceDataTriggerFunction
    {
        private static HttpClient client = new HttpClient();

        [FunctionName("device-data-trigger")]
        public static async Task Run([IoTHubTrigger("messages/events", Connection = "IoTHubConnectionString")]EventData message, ILogger log)
        {
            var messageBody = Encoding.UTF8.GetString(message.Body.Array);
            log.LogInformation($"C# IoT Hub trigger function processed a message: {messageBody}");

            HttpContent messageContent = new StringContent(messageBody, Encoding.UTF8, "application/json");
            var broadcastFunctionUrl = Environment.GetEnvironmentVariable("DeviceDataTriggerFunctionUrl", EnvironmentVariableTarget.Process);
            await client.PostAsync(broadcastFunctionUrl, messageContent);
        }
    }
```

As you can see first sensor's data is retrieved and then this data is passed to the next function - "Messages". Url of this next function is stored in the app settings under "DeviceDataTriggerFunctionUrl" setting name.


## Messages function config

"Messages" function app is used to broadcast messages to all clients connected to the SignalR service.

```csharp
        [FunctionName("messages")]
        public static Task SendMessage(
            [HttpTrigger(AuthorizationLevel.Anonymous, "post")] string message,
            [SignalR(HubName = "devicedata")] IAsyncCollector<SignalRMessage> signalRMessages)
        {
            return signalRMessages.AddAsync(
                new SignalRMessage
                {
                    Target = "newMessage",
                    Arguments = new[] { message }
                });
        }
```


## Negotiate function config

Negotiate Azure Function is used to connect to the SignalR service and get connection info. This connection info will be used by UWP application to receive real time data.

```csharp
        [FunctionName("negotiate")]
        public static SignalRConnectionInfo GetSignalRInfo(
           [HttpTrigger(AuthorizationLevel.Anonymous, "get")] HttpRequest req,
           [SignalRConnectionInfo(HubName = "devicedata")] SignalRConnectionInfo connectionInfo)
        {
            return connectionInfo;
        }
```

Source code for the function apps is available on my [GitHub](https://github.com/Daniel-Krzyczkowski/MicrosoftAzure/tree/master/ServerlessIoT).

## Azure resource group overview

My final resource group looks like below:

<p align="center">
<img src="/images/devisland/article21/assets/ServerlessIoT4.PNG?raw=true" alt="Image not found"/>
</p>


## UWP application config

<p align="center">
<img src="/images/devisland/article21/assets/ServerlessIoT3.png?raw=true" alt="Image not found"/>
</p>

I created Universal Windows 10 Platform application to display real time data from the IoT device. It is available on my [GitHub](https://github.com/Daniel-Krzyczkowski/UniversalWindowsPlatform/tree/master/ServerlessIoT-UWP). UWP application first calls "negotiate" function app and once connection info is returned, app is connected to the SignalR service hub. This is done using two classes:

1. **SignalRAccessTokenProvider** - in this class there is a call to the "Negotiate" function app to retrieve SignalR connection info
2. **ClientSignalR** - this class is responsible for connection with SignalR service (including messages subscription)

```csharp
    public class ClientSignalR : IClientSignalR
    {
        private ISignalRAccessTokenProvider _signalRAccessTokenProvider;

        private HubConnection _hub;
        public HubConnection Hub
        {
            get
            {
                return _hub;
            }
        }

        public ClientSignalR(ISignalRAccessTokenProvider signalRAccessTokenProvider)
        {
            _signalRAccessTokenProvider = signalRAccessTokenProvider;
        }

        public async Task Initialize()
        {
            var connectionInfo = await _signalRAccessTokenProvider.AcquireSignalRConnectionInfoAsync();
            if (connectionInfo == null)
            {
                throw new ArgumentNullException("SignalR connection info is empty");
            }

            _hub = new HubConnectionBuilder()
                .WithUrl(connectionInfo.Url, options =>
                {
                    options.AccessTokenProvider = async () =>
                    {
                        var accessToken = await _signalRAccessTokenProvider.AcquireSignalRConnectionInfoAsync();
                        return accessToken?.AccessToken;
                    };
                })
                .Build();

            await _hub.StartAsync();
        }


        public void SubscribeHubMethod(string methodName)
        {
            _hub.On<string>(methodName, (data) =>
            {
                OnMessageReceived?.Invoke(data);
            });
        }

        public async Task SendHubMessage(string methodName, string data)
        {
            await _hub?.InvokeAsync(methodName, data);
        }

        public async Task CloseConnection()
        {
            await _hub.DisposeAsync();
        }

        public event Action<string> OnMessageReceived;
    }
```

Here is the **SignalRAccessTokenProvider** implementation:

```csharp
    public class SignalRAccessTokenProvider : ISignalRAccessTokenProvider
    {
        private HttpClient _httpClient;

        public SignalRAccessTokenProvider()
        {
            _httpClient = new HttpClient()
            {
                BaseAddress = new Uri(AppConfig.DeviceDataBroadcastFunctionUrl)
            };
        }

        public async Task<SignalRConnectionInfo> AcquireSignalRConnectionInfoAsync()
        {
            var responseMessage = await _httpClient.GetAsync("negotiate");
            var responseContent = await responseMessage
            .Content
            .ReadAsStringAsync();

            if (responseMessage.IsSuccessStatusCode)
            {
                var signalRConnectionInfo = JsonConvert.DeserializeObject<SignalRConnectionInfo>(responseContent);

                return signalRConnectionInfo;
            }
            else
            {
                System.Diagnostics.Debug.WriteLine($"No success for acquiring SignalR service token in method: {nameof(AcquireSignalRConnectionInfoAsync)}");
                System.Diagnostics.Debug.WriteLine($"Http status code: {responseMessage.StatusCode} message: {responseContent}");
                return null;
            }
        }
    }
```


## Summary

In this article I showed how to connect together Azure serverless services - Azure Functions and SignalR service to provide real time data to the UWP application from the IoT device. Of course this is a sample scenario - you could use these services in the different way (live updates about users registrations or location changes) - the main purpose was to show how to use them together.